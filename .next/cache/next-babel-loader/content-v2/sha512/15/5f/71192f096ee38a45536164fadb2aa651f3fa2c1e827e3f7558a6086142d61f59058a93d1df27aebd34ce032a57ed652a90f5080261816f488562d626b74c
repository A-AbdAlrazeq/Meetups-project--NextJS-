{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"D:\\\\react\\\\06-onwards-to-a-bigger-project-starting-project\\\\pages\\\\index.js\";\nimport { useEffect, useState } from \"react\";\nimport MeetupList from \"../components/meetups/MeetupList\";\nconst DUMMY_MEETUPS = [{\n  id: \"m1\",\n  title: \"A First Meetup\",\n  image: \"https://upload.wikimedia.org/wikipedia/commons/d/d3/Stadtbild_M%C3%BCnchen.jpg\",\n  address: \"Some address 5,123\",\n  description: \"this is a first meetup\"\n}, {\n  id: \"m2\",\n  title: \"A second Meetup\",\n  image: \"https://upload.wikimedia.org/wikipedia/commons/d/d3/Stadtbild_M%C3%BCnchen.jpg\",\n  address: \"Some address 5,124323\",\n  description: \"this is a second meetup\"\n}];\n\nfunction Homepage(props) {\n  /* const [loadedMeetups, setLoadedMeetups] = useState([]);\r\n  useEffect(() => {\r\n    send a http request and fetch data\r\n     we have two component render cycle,the first render will be the initial state (empty array),so we have problem with SEO,and in view source code the data missing\r\n     the next js does not wait for second render cycle ,it will take the result from first render and return that as pre-render html code,so next js will not wait data to be fetch\r\n     it's will return the result of first render cycle\r\n     two form of pre-rendering:\r\n    static generation:it's pre-render when developer build website for production(by run npm run build script),so if you update the data and page need to change,you need to start\r\n    that's build process again\r\n    server side rendering(ssr) \r\n    setLoadedMeetups(DUMMY_MEETUPS);\r\n  }, []); if we want to send http req when page rendered we must use useEffect,empty array mean it's will run just first render */\n  return /*#__PURE__*/_jsxDEV(MeetupList, {\n    meetups: props.meetups\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 34,\n    columnNumber: 10\n  }, this);\n}\n/* this function will run always on the server after deployment */\n\n\nexport async function getServerSideProps(context) {\n  //any code write here will run on server,never on client\n  const req = context.req;\n  const res = context.res;\n  return {\n    props: {\n      meetups: DUMMY_MEETUPS\n    } //revalidate: 10,not make sense to add it here,because function run for every incoming request anyway,no need to revalidate it every x second\n\n  };\n}\n/* next js if find this function getStaticProps will execute it when pre-rendering process,first of all will execute this function before component func,\r\nthe job for this func is prepare props for this page and it's can be async func,will return promise so now we can load data before comp func execute ,the code in this func it's\r\njust execute just in build process,so it will not run on client side\r\nexport async function getStaticProps() {\r\n  fetch data from API\r\n  now no need for state and useEffect because we get the data through props,so now we can see the data inside view page source it's now contains full html code and now great \r\n  for SEO,now the dta is not fetched in second pre-render cycle,before the page pre-render during the build process\r\nreturn {\r\n  props: { meetups: DUMMY_MEETUPS },\r\n  revalidate: 10,\r\n  /*when we add this property,we unlock features called incremental static generation,this number is the second that next js will wait \r\n    until regenerates page for incoming request,it's will generated every couple of seconds on the server,at least if there's request for this page,so it will replace the old\r\n    pre-generated page,tha page will update after deployment but sometime update is not enough,you need to \r\n    re generate the page\r\n  }; \r\n};*/\n\n/* getServerSideProps: might it's better to run for every request ,but it's disadvantage because you need\r\nto wait your page to generate for every incoming request,if you don't have data change many time(every second) \r\nand you don't need to access request object (ex:for auth) use getStaticProps\r\n getStaticProps: */\n\nexport default Homepage;","map":{"version":3,"sources":["D:/react/06-onwards-to-a-bigger-project-starting-project/pages/index.js"],"names":["useEffect","useState","MeetupList","DUMMY_MEETUPS","id","title","image","address","description","Homepage","props","meetups","getServerSideProps","context","req","res"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,OAAOC,UAAP,MAAuB,kCAAvB;AACA,MAAMC,aAAa,GAAG,CACpB;AACEC,EAAAA,EAAE,EAAE,IADN;AAEEC,EAAAA,KAAK,EAAE,gBAFT;AAGEC,EAAAA,KAAK,EACH,gFAJJ;AAKEC,EAAAA,OAAO,EAAE,oBALX;AAMEC,EAAAA,WAAW,EAAE;AANf,CADoB,EASpB;AACEJ,EAAAA,EAAE,EAAE,IADN;AAEEC,EAAAA,KAAK,EAAE,iBAFT;AAGEC,EAAAA,KAAK,EACH,gFAJJ;AAKEC,EAAAA,OAAO,EAAE,uBALX;AAMEC,EAAAA,WAAW,EAAE;AANf,CAToB,CAAtB;;AAkBA,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AACvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,sBAAO,QAAC,UAAD;AAAY,IAAA,OAAO,EAAEA,KAAK,CAACC;AAA3B;AAAA;AAAA;AAAA;AAAA,UAAP;AACD;AACD;;;AACA,OAAO,eAAeC,kBAAf,CAAkCC,OAAlC,EAA2C;AAChD;AACA,QAAMC,GAAG,GAAGD,OAAO,CAACC,GAApB;AACA,QAAMC,GAAG,GAAGF,OAAO,CAACE,GAApB;AACA,SAAO;AACLL,IAAAA,KAAK,EAAE;AAAEC,MAAAA,OAAO,EAAER;AAAX,KADF,CAEL;;AAFK,GAAP;AAID;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA,eAAeM,QAAf","sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport MeetupList from \"../components/meetups/MeetupList\";\r\nconst DUMMY_MEETUPS = [\r\n  {\r\n    id: \"m1\",\r\n    title: \"A First Meetup\",\r\n    image:\r\n      \"https://upload.wikimedia.org/wikipedia/commons/d/d3/Stadtbild_M%C3%BCnchen.jpg\",\r\n    address: \"Some address 5,123\",\r\n    description: \"this is a first meetup\",\r\n  },\r\n  {\r\n    id: \"m2\",\r\n    title: \"A second Meetup\",\r\n    image:\r\n      \"https://upload.wikimedia.org/wikipedia/commons/d/d3/Stadtbild_M%C3%BCnchen.jpg\",\r\n    address: \"Some address 5,124323\",\r\n    description: \"this is a second meetup\",\r\n  },\r\n];\r\nfunction Homepage(props) {\r\n  /* const [loadedMeetups, setLoadedMeetups] = useState([]);\r\n  useEffect(() => {\r\n    send a http request and fetch data\r\n     we have two component render cycle,the first render will be the initial state (empty array),so we have problem with SEO,and in view source code the data missing\r\n     the next js does not wait for second render cycle ,it will take the result from first render and return that as pre-render html code,so next js will not wait data to be fetch\r\n     it's will return the result of first render cycle\r\n     two form of pre-rendering:\r\n    static generation:it's pre-render when developer build website for production(by run npm run build script),so if you update the data and page need to change,you need to start\r\n    that's build process again\r\n    server side rendering(ssr) \r\n    setLoadedMeetups(DUMMY_MEETUPS);\r\n  }, []); if we want to send http req when page rendered we must use useEffect,empty array mean it's will run just first render */\r\n  return <MeetupList meetups={props.meetups} />;\r\n}\r\n/* this function will run always on the server after deployment */\r\nexport async function getServerSideProps(context) {\r\n  //any code write here will run on server,never on client\r\n  const req = context.req;\r\n  const res = context.res;\r\n  return {\r\n    props: { meetups: DUMMY_MEETUPS },\r\n    //revalidate: 10,not make sense to add it here,because function run for every incoming request anyway,no need to revalidate it every x second\r\n  };\r\n}\r\n/* next js if find this function getStaticProps will execute it when pre-rendering process,first of all will execute this function before component func,\r\nthe job for this func is prepare props for this page and it's can be async func,will return promise so now we can load data before comp func execute ,the code in this func it's\r\njust execute just in build process,so it will not run on client side\r\nexport async function getStaticProps() {\r\n  fetch data from API\r\n  now no need for state and useEffect because we get the data through props,so now we can see the data inside view page source it's now contains full html code and now great \r\n  for SEO,now the dta is not fetched in second pre-render cycle,before the page pre-render during the build process\r\nreturn {\r\n  props: { meetups: DUMMY_MEETUPS },\r\n  revalidate: 10,\r\n  /*when we add this property,we unlock features called incremental static generation,this number is the second that next js will wait \r\n    until regenerates page for incoming request,it's will generated every couple of seconds on the server,at least if there's request for this page,so it will replace the old\r\n    pre-generated page,tha page will update after deployment but sometime update is not enough,you need to \r\n    re generate the page\r\n  }; \r\n};*/\r\n/* getServerSideProps: might it's better to run for every request ,but it's disadvantage because you need\r\nto wait your page to generate for every incoming request,if you don't have data change many time(every second) \r\nand you don't need to access request object (ex:for auth) use getStaticProps\r\n getStaticProps: */\r\nexport default Homepage;\r\n"]},"metadata":{},"sourceType":"module"}