{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"D:\\\\react\\\\06-onwards-to-a-bigger-project-starting-project\\\\pages\\\\index.js\";\nimport { MongoClient } from \"mongodb\";\nimport Head from \"next/head\";\nimport { Fragment } from \"react\";\nimport MeetupList from \"../components/meetups/MeetupList\";\n/* if we import something and it's used just in export async function getStaticProps or getServerSideProps =>the import package will not be of client side bundle\r\nwill be execute just on server  and next js will detect it and will not include it in client side which is good for bundle size consideration and for security\r\nso you can import server side and client side depending where to use it while include in different bundle    */\n\nfunction Homepage(props) {\n  /* const [loadedMeetups, setLoadedMeetups] = useState([]);\r\n  useEffect(() => {\r\n    send a http request and fetch data\r\n     we have two component render cycle,the first render will be the initial state (empty array),so we have problem with SEO,and in view source code the data missing\r\n     the next js does not wait for second render cycle ,it will take the result from first render and return that as pre-render html code,so next js will not wait data to be fetch\r\n     it's will return the result of first render cycle\r\n     two form of pre-rendering:\r\n    static generation:it's pre-render when developer build website for production(by run npm run build script),so if you update the data and page need to change,you need to start\r\n    that's build process again\r\n    server side rendering(ssr) \r\n    setLoadedMeetups(DUMMY_MEETUPS);\r\n  }, []); if we want to send http req when page rendered we must use useEffect,empty array mean it's will run just first render */\n\n  /*#__PURE__*/\n  _jsxDEV(Fragment, {\n    children: /*#__PURE__*/_jsxDEV(Head, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 5\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 23,\n    columnNumber: 3\n  }, this);\n\n  return /*#__PURE__*/_jsxDEV(MeetupList, {\n    meetups: props.meetups\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 26,\n    columnNumber: 10\n  }, this);\n} //this function will run always on the server after deployment\n\n/* export async function getServerSideProps(context) {\r\n  //any code write here will run on server,never on client\r\n  const req = context.req;\r\n  const res = context.res;\r\n  return {\r\n    props: { meetups: DUMMY_MEETUPS },\r\n    //revalidate: 10,not make sense to add it here,because function run for every incoming request\r\n    //anyway,no need to revalidate it every x second\r\n  };\r\n} */\n\n/* next js if find this function getStaticProps will execute it when pre-rendering process,first of all will execute this function before component func,\r\nthe job for this func is prepare props for this page and it's can be async func,will return promise so now we can load data before comp func execute ,the code in this func it's\r\njust execute just in build process,so it will not run on client side */\n\n\nexport async function getStaticProps() {\n  /* fetch data from API\r\n  now no need for state and useEffect because we get the data through props,so now we can see the data inside view page source it's now contains full html code and now great \r\n  for SEO,now the data is not fetched in second pre-render cycle,before the page pre-render during the build process */\n\n  /*this code only run on server side or during build time never in client, instead of create meetup file in api folder we can write the code here directly\r\n  because this code run directly on server side never on client,we don't need to send unnecessary request to our api route\r\n  \r\n  this code only run just when page pre-generated not for every incoming request on build process or when revalidate the page*/\n  const client = await MongoClient.connect(\"mongodb+srv://Abood:Abood123ax@next-js.syz3y0l.mongodb.net/?retryWrites=true&w=majority\");\n  const db = client.db();\n  const meetupsCollection = db.collection(\"meetups\"); //find by default will find all document in that collection,we use to array to get back array of doc\n\n  const meetups = await meetupsCollection.find().toArray();\n  client.close();\n  return {\n    //we must map ot because the id is complex object\n    props: {\n      meetups: meetups.map(meetup => ({\n        title: meetup.title,\n        address: meetup.address,\n        image: meetup.image,\n        id: meetup._id.toString() //here we convert the object to string to be usable\n\n      }))\n    },\n    revalidate: 1\n    /*  when we add this property,we unlock features called incremental static generation,this number is the second that next js will wait \r\n    until regenerates page for incoming request,it's will generated every couple of seconds on the server,at least if there's request for this page,so it will replace the old\r\n    pre-generated page,tha page will update after deployment but sometime update is not enough,you need to \r\n    re generate the page */\n\n  };\n}\n/* getServerSideProps: might it's better to run for every request ,but it's disadvantage because you need\r\nto wait your page to generate for every incoming request,if you don't have data change many time(every second) \r\nand you don't need to access request object (ex:for auth) use getStaticProps will be better.\r\n getStaticProps: pre-generate a html file can be stored and served by CDN and simply faster tha re-generating\r\n and fetching that data for every incoming request,so it will be faster because it can cached and reused instead\r\n of regenerated all the time,you don't have access to req and res in getStaticProps  */\n\nexport default Homepage;","map":{"version":3,"sources":["D:/react/06-onwards-to-a-bigger-project-starting-project/pages/index.js"],"names":["MongoClient","Head","Fragment","MeetupList","Homepage","props","meetups","getStaticProps","client","connect","db","meetupsCollection","collection","find","toArray","close","map","meetup","title","address","image","id","_id","toString","revalidate"],"mappings":";;AAAA,SAASA,WAAT,QAA4B,SAA5B;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,SAASC,QAAT,QAAyB,OAAzB;AACA,OAAOC,UAAP,MAAuB,kCAAvB;AACA;AACA;AACA;;AAEA,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AACvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AAAA,UAAC,QAAD;AAAA,2BACE,QAAC,IAAD;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA;;AAGA,sBAAO,QAAC,UAAD;AAAY,IAAA,OAAO,EAAEA,KAAK,CAACC;AAA3B;AAAA;AAAA;AAAA;AAAA,UAAP;AACD,C,CACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,OAAO,eAAeC,cAAf,GAAgC;AACrC;AACF;AACA;;AACE;AACF;AACA;AACA;AACE,QAAMC,MAAM,GAAG,MAAMR,WAAW,CAACS,OAAZ,CACnB,yFADmB,CAArB;AAGA,QAAMC,EAAE,GAAGF,MAAM,CAACE,EAAP,EAAX;AACA,QAAMC,iBAAiB,GAAGD,EAAE,CAACE,UAAH,CAAc,SAAd,CAA1B,CAZqC,CAarC;;AACA,QAAMN,OAAO,GAAG,MAAMK,iBAAiB,CAACE,IAAlB,GAAyBC,OAAzB,EAAtB;AACAN,EAAAA,MAAM,CAACO,KAAP;AACA,SAAO;AACL;AACAV,IAAAA,KAAK,EAAE;AACLC,MAAAA,OAAO,EAAEA,OAAO,CAACU,GAAR,CAAaC,MAAD,KAAa;AAChCC,QAAAA,KAAK,EAAED,MAAM,CAACC,KADkB;AAEhCC,QAAAA,OAAO,EAAEF,MAAM,CAACE,OAFgB;AAGhCC,QAAAA,KAAK,EAAEH,MAAM,CAACG,KAHkB;AAIhCC,QAAAA,EAAE,EAAEJ,MAAM,CAACK,GAAP,CAAWC,QAAX,EAJ4B,CAIL;;AAJK,OAAb,CAAZ;AADJ,KAFF;AAULC,IAAAA,UAAU,EAAE;AACZ;AACJ;AACA;AACA;;AAdS,GAAP;AAgBD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,eAAepB,QAAf","sourcesContent":["import { MongoClient } from \"mongodb\";\r\nimport Head from \"next/head\";\r\nimport { Fragment } from \"react\";\r\nimport MeetupList from \"../components/meetups/MeetupList\";\r\n/* if we import something and it's used just in export async function getStaticProps or getServerSideProps =>the import package will not be of client side bundle\r\nwill be execute just on server  and next js will detect it and will not include it in client side which is good for bundle size consideration and for security\r\nso you can import server side and client side depending where to use it while include in different bundle    */\r\n\r\nfunction Homepage(props) {\r\n  /* const [loadedMeetups, setLoadedMeetups] = useState([]);\r\n  useEffect(() => {\r\n    send a http request and fetch data\r\n     we have two component render cycle,the first render will be the initial state (empty array),so we have problem with SEO,and in view source code the data missing\r\n     the next js does not wait for second render cycle ,it will take the result from first render and return that as pre-render html code,so next js will not wait data to be fetch\r\n     it's will return the result of first render cycle\r\n     two form of pre-rendering:\r\n    static generation:it's pre-render when developer build website for production(by run npm run build script),so if you update the data and page need to change,you need to start\r\n    that's build process again\r\n    server side rendering(ssr) \r\n    setLoadedMeetups(DUMMY_MEETUPS);\r\n  }, []); if we want to send http req when page rendered we must use useEffect,empty array mean it's will run just first render */\r\n\r\n  <Fragment>\r\n    <Head></Head>\r\n  </Fragment>;\r\n  return <MeetupList meetups={props.meetups} />;\r\n}\r\n//this function will run always on the server after deployment\r\n/* export async function getServerSideProps(context) {\r\n  //any code write here will run on server,never on client\r\n  const req = context.req;\r\n  const res = context.res;\r\n  return {\r\n    props: { meetups: DUMMY_MEETUPS },\r\n    //revalidate: 10,not make sense to add it here,because function run for every incoming request\r\n    //anyway,no need to revalidate it every x second\r\n  };\r\n} */\r\n\r\n/* next js if find this function getStaticProps will execute it when pre-rendering process,first of all will execute this function before component func,\r\nthe job for this func is prepare props for this page and it's can be async func,will return promise so now we can load data before comp func execute ,the code in this func it's\r\njust execute just in build process,so it will not run on client side */\r\nexport async function getStaticProps() {\r\n  /* fetch data from API\r\n  now no need for state and useEffect because we get the data through props,so now we can see the data inside view page source it's now contains full html code and now great \r\n  for SEO,now the data is not fetched in second pre-render cycle,before the page pre-render during the build process */\r\n  /*this code only run on server side or during build time never in client, instead of create meetup file in api folder we can write the code here directly\r\n  because this code run directly on server side never on client,we don't need to send unnecessary request to our api route\r\n  \r\n  this code only run just when page pre-generated not for every incoming request on build process or when revalidate the page*/\r\n  const client = await MongoClient.connect(\r\n    \"mongodb+srv://Abood:Abood123ax@next-js.syz3y0l.mongodb.net/?retryWrites=true&w=majority\"\r\n  );\r\n  const db = client.db();\r\n  const meetupsCollection = db.collection(\"meetups\");\r\n  //find by default will find all document in that collection,we use to array to get back array of doc\r\n  const meetups = await meetupsCollection.find().toArray();\r\n  client.close();\r\n  return {\r\n    //we must map ot because the id is complex object\r\n    props: {\r\n      meetups: meetups.map((meetup) => ({\r\n        title: meetup.title,\r\n        address: meetup.address,\r\n        image: meetup.image,\r\n        id: meetup._id.toString(), //here we convert the object to string to be usable\r\n      })),\r\n    },\r\n    revalidate: 1,\r\n    /*  when we add this property,we unlock features called incremental static generation,this number is the second that next js will wait \r\n    until regenerates page for incoming request,it's will generated every couple of seconds on the server,at least if there's request for this page,so it will replace the old\r\n    pre-generated page,tha page will update after deployment but sometime update is not enough,you need to \r\n    re generate the page */\r\n  };\r\n}\r\n\r\n/* getServerSideProps: might it's better to run for every request ,but it's disadvantage because you need\r\nto wait your page to generate for every incoming request,if you don't have data change many time(every second) \r\nand you don't need to access request object (ex:for auth) use getStaticProps will be better.\r\n getStaticProps: pre-generate a html file can be stored and served by CDN and simply faster tha re-generating\r\n and fetching that data for every incoming request,so it will be faster because it can cached and reused instead\r\n of regenerated all the time,you don't have access to req and res in getStaticProps  */\r\nexport default Homepage;\r\n"]},"metadata":{},"sourceType":"module"}